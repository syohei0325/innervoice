export const runtime = 'nodejs';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { v4 as uuidv4 } from 'uuid';

export async function POST(request: NextRequest) {
  try {
    const { proposal_id } = await request.json();
    
    if (!proposal_id) {
      return NextResponse.json(
        { error: 'Proposal ID is required' },
        { status: 400 }
      );
    }

    // For MVP, we'll use a mock user ID
    // TODO: Implement proper user authentication
    const mockUserId = 'user_mock_001';
    
    // Find the proposal (for now, we'll create mock proposal data)
    // TODO: Actually retrieve from proposals table
    const mockProposal = {
      id: proposal_id,
      title: "選択されたタスク",
      slot: "09:00",
      duration_min: 20
    };

    // Generate .ics content
    const eventId = uuidv4();
    const now = new Date();
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    // Parse slot time (HH:MM)
    const [hours, minutes] = mockProposal.slot.split(':').map(Number);
    const startTime = new Date(tomorrow);
    startTime.setHours(hours, minutes, 0, 0);
    
    const endTime = new Date(startTime);
    endTime.setMinutes(endTime.getMinutes() + mockProposal.duration_min);

    const icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//InnerVoice//EN
BEGIN:VEVENT
UID:${eventId}@innervoice.app
DTSTART:${startTime.toISOString().replace(/[-:]/g, '').split('.')[0]}Z
DTEND:${endTime.toISOString().replace(/[-:]/g, '').split('.')[0]}Z
SUMMARY:${mockProposal.title}
DESCRIPTION:Generated by InnerVoice (${mockProposal.duration_min}分)
END:VEVENT
END:VCALENDAR`;

    // Calculate minutes back (simplified for MVP)
    const minutesBack = Math.max(mockProposal.duration_min - 5, 0); // Assume 5min saved
    
    try {
      // Save decision to database
      await prisma.decision.create({
        data: {
          userId: mockUserId,
          proposalId: proposal_id,
          icsBlob: icsContent,
          minutesBack: minutesBack,
        },
      });

      // Log event
      await prisma.event.create({
        data: {
          userId: mockUserId,
          source: 'confirmed',
          minutesBack: minutesBack,
          metaJson: JSON.stringify({ proposalId: proposal_id }),
        },
      });
    } catch (dbError) {
      console.error('Database error (continuing with response):', dbError);
      // Continue with response even if DB fails for MVP
    }

    return NextResponse.json({
      ics_url: `/api/download/${eventId}`,
      minutes_back: minutesBack
    });
  } catch (error) {
    console.error('Error in /api/confirm:', error);
    return NextResponse.json(
      { error: 'Failed to confirm proposal' },
      { status: 500 }
    );
  }
}
